#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, in2,    robotAngle,     sensorGyro)
#pragma config(Sensor, dgtl1,  RobotEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  autoL,          sensorDigitalIn)
#pragma config(Sensor, dgtl4,  autoR,          sensorDigitalIn)
#pragma config(Sensor, dgtl5,  planA,          sensorDigitalIn)
#pragma config(Sensor, dgtl6,  planB,          sensorDigitalIn)
#pragma config(Sensor, dgtl7,  planC,          sensorDigitalIn)
#pragma config(Motor,  port2,           frontRightWheel, tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           backLeftWheel, tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           armLeftMotor,  tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           armRightMotor, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           backRightWheel, tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           frontLeftWheel, tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

/************************************************************************************/
/************************************* Setting **************************************/
/************************************************************************************/
//Slect the operating habits
#define HJM
//Automatically lower the robot arm
#define AUTOPUTDOWN true

#ifdef HJM
#define mainJoyY Ch3
#define mainJoyX Ch4
#define secondaryJoyY Ch2
#define secondaryJoyX Ch1
#endif

#ifdef XPZ
#define mainJoyY Ch2
#define mainJoyX Ch1
#define secondaryJoyY Ch3
#define secondaryJoyX Ch4
#endif
/************************************************************************************/
/************************************** Common **************************************/
/************************************************************************************/

bool auto_7L = false, auto_7R = false, auto_7D = false, auto_7U = false;

void setArmMotor(int power)
{
	motor[armLeftMotor] = power;
	motor[armRightMotor]= power;
}

void setArmMotorWithHighTech(int power)
//Better linear performance
{
	if(power > 2)
	{
		motor[armLeftMotor] = power*0.92 + 8;
		motor[armRightMotor]= power*0.92 + 8;
	}
	else if(power < -2)
	{
		motor[armLeftMotor] = power*0.92 - 8;
		motor[armRightMotor]= power*0.92 - 8;
	}
	else
	{
		motor[armLeftMotor] = 0;
		motor[armRightMotor]= 0;
	}
}

void putDownArm(void)
{
	int lastAngle;
	//Quickly lower the robot arm
	setArmMotor(-127);
	delay(100);
	do{
		lastAngle = SensorValue[armAngle];
		delay(50);
	}while(lastAngle - SensorValue[armAngle] > 0 && SensorValue[armAngle] > 1500);
	//Slowly approaching the lowest position(When stopped, stop)
	setArmMotor(-40);
	do{
		lastAngle = SensorValue[armAngle];
		delay(50);
	}while(lastAngle - SensorValue[armAngle] > 0);
	if(SensorValue[armAngle] < 1100)
	//if successfully put down,power up briefly to ensure that it is in place
	{
		delay(50);
		setArmMotor(-100);
		delay(100);
	}
	else
	//If it fails, lift it lightly
	{
		setArmMotor(100);
		delay(100);
	}
	setArmMotor(-10);//Make it static
}

void putUpArm(void)
{
	//Full-speed elevation until blocked
	int lastAngle;
	setArmMotor(127);
	delay(100);
	do{
		lastAngle = SensorValue[armAngle];
		delay(50);
	}while(SensorValue[armAngle] - lastAngle > 0 && SensorValue[armAngle] < 3000);
}

#define LOWEST -1
#define HIGHEST -2
task armControl()
{
	enum STATE{remainToBeDone, working, done, pause};
	enum STATE stata = done;
	int aim = LOWEST;
	long iNow;int pNow, vNow;
	int pLast;
	int kP, kI, kV, slewRate, maxPower;
	int power = 0, lastPower;

	while(true)
	{
		//Button recognition and preprocessing
		if(time1[T1] > 300)//Prevent double-click
		{
			if(vexRT[Btn8D] || vexRT[Btn7D] || auto_7D)
			{
				auto_7D = false;
				aim = LOWEST;
				stata = remainToBeDone;
			}
			if(vexRT[Btn8R] || vexRT[Btn7L] || auto_7L)
			{
				auto_7L = false;
				int lastAngle;
				clearTimer(T2);
				setArmMotor(80);
				int angleStart = SensorValue[armAngle];
				clearTimer(T3);
				do{
					lastAngle = SensorValue[armAngle];
					if(lastAngle - angleStart > 250 //check when lifting a certain angle
						&& (time1[T3] < 320 //if lifting too fast
						|| motor[frontLeftWheel] < -60 || motor[frontRightWheel] < -60))
						//or when the driver reversing(This means that the driver thinks the action has been done)
					{
						writeDebugStream("%d\n",time1[T3]);
						setArmMotor(-10);
						delay(150);
						setArmMotor(0);
						break;
					}
					delay(10);
				}while(SensorValue[armAngle] < 1350 && time1[T2] < 600);
				aim = 1550;
				stata = remainToBeDone;
			}
			if(vexRT[Btn8U] || vexRT[Btn7U] || auto_7U)
			{
				auto_7U = false;
				aim = HIGHEST;
				stata = remainToBeDone;
			}
			if(vexRT[Btn8L] || vexRT[Btn7R] || auto_7R)
			{
				auto_7R = false;
				int lastAngle;
				clearTimer(T2);
				setArmMotor(127);
				do{
					lastAngle = SensorValue[armAngle];
					delay(50);
				}while(SensorValue[armAngle] < 2100 && time1[T2] < 400);
				setArmMotor(0);

				aim = 2700;
				stata = remainToBeDone;
			}
		}
		if(stata == remainToBeDone)
			clearTimer(T1);

		//Perform the operation
		if(aim == LOWEST && stata != done)
		{
			putDownArm();
			stata = done;
		}
		else if(aim == HIGHEST && stata != done)
		{
			putUpArm();
			if(AUTOPUTDOWN)
			{
				delay(200);
				putDownArm();
			}
			stata = done;
		}
		else if(aim != HIGHEST && aim != LOWEST)
		{
			if(stata == remainToBeDone)//The first cycle of PID, initialization
			{
				stata = working;
				pLast = pNow = aim - SensorValue[armAngle];
				iNow = 0;
				vNow = 0;
				clearTimer(T3);
			}
			else//Process sensor data
			{
				pLast = pNow;
				pNow = aim - SensorValue[armAngle];
				iNow += pNow;
				vNow = pLast - pNow;
			}

			//Dynamically set parameters
			kP = 60;
			kI = 10;
			if(abs(kI*iNow) > 40000)//When stuck, remove the exception
				iNow = 40000/kI*sgn(iNow);
			kV = 400;
			slewRate = 15;

			maxPower = 127;
			if(time1[T3] > 500)
				maxPower = 25;
			if(time1[T3] > 1000)
				maxPower = 9;
			if(abs(pNow) < 50)
				maxPower = 5;

			lastPower = power;
			//Calculates the raw output
			power = (int)((kP*pNow + kI*iNow - kV*vNow)/1000);

			//Smooth change of motor power
			if(power - lastPower > slewRate)
				power = lastPower + slewRate;
			else if(lastPower - power > slewRate)
				power = lastPower - slewRate;

			//Limit to maximum power
			if(power > maxPower)
				power = maxPower;
			else if(power < -maxPower)
				power = -maxPower;

			//output to arm motor
			setArmMotorWithHighTech(power);
			delay(30);
		}
		delay(20);
	}
}

/************************************************************************************/
/******************************** Automous ******************************************/
/********************6****************************************************************/

void pre_auton()
{
	bStopTasksBetweenModes = true;
	setArmMotor(-8);
}
#include "autoPlanAR.c"
#include "autoPlanAL.c"
#include "autoPlanBR.c"
#include "autoPlanBL.c"
#include "autoPlanCR.c"
#include "autoPlanCL.c"
task autonomous()
{
	clearTimer(T4);
	if(!SensorValue[autoL])
	{
		if(!SensorValue[planA])
			autoPlanAL();
		else if(!SensorValue[planC])
			autoPlanCL();
		else//B is the default plan
			autoPlanBL();
	}
	else if(!SensorValue[autoR])
	{
		if(!SensorValue[planA])
			autoPlanAR();
		else if(!SensorValue[planC])
			autoPlanCR();
		else//B is the default plan
			autoPlanBR();
	}
	writeDebugStream("%d\n",time1[T4]);
}
/************************************************************************************/
/******************************* User control ***************************************/
/************************************************************************************/
task usercontrol()
{
	startTask(armControl);
	int threshold = 20;
	int mainX = 0,mainY = 0,secondaryX = 0,secondaryY = 0;
	while(true)
	{
		if(abs(vexRT[mainJoyY]) >= threshold)	mainY = vexRT[mainJoyY];
		else	mainY = 0;
		if(abs(vexRT[mainJoyX]) >= threshold)	mainX = vexRT[mainJoyX];
		else	mainX = 0;
		if(abs(vexRT[secondaryJoyY]) >= threshold)	secondaryY = vexRT[secondaryJoyY];
		else	secondaryY = 0;
		if(abs(vexRT[secondaryJoyX]) >= threshold)	secondaryX = vexRT[secondaryJoyX];
		else	secondaryX = 0;

		if(abs(mainY) < abs(secondaryY))
			mainY = secondaryY;
		if(abs(mainX) < 40)
			mainX /= 2;

		motor[frontLeftWheel] = mainY + secondaryX + mainX;
		motor[frontRightWheel]= mainY - secondaryX - mainX;
		motor[backLeftWheel]  = mainY - secondaryX + mainX;
		motor[backRightWheel] = mainY + secondaryX - mainX;

		delay(20);
	}
}
